import torch
import numpy as np
from torch.utils.data import Dataset

# Handle import for _compute_normals from same directory
try:
    from _compute_normals import compute_pointcloud_normals
except ImportError:
    import os
    import sys
    # Add src directory to path
    src_path = os.path.dirname(os.path.abspath(__file__))
    if src_path not in sys.path:
        sys.path.insert(0, src_path)
    from _compute_normals import compute_pointcloud_normals


def compute_pointcloud_normals_for_dataset(points, normal_params=None):
    """
    Compute normals for a pointcloud dataset (2D or 3D).
    
    Parameters:
    -----------
    points : np.ndarray or torch.Tensor
        Point cloud data of shape (N, D) where D is 2 or 3
    normal_params : dict, optional
        Parameters for normal computation. If None, uses defaults.
        For 2D: {'k_neighbors': 10}
        For 3D: {'radius': 0.1, 'max_neighbors': 30}
        
    Returns:
    --------
    normals : np.ndarray
        Array of shape (N, D) containing unit normal vectors
    """
    # Convert to numpy if tensor
    if isinstance(points, torch.Tensor):
        points_np = points.detach().cpu().numpy()
    else:
        points_np = points
    
    # Set default parameters if not provided
    if normal_params is None:
        print(f"No normal parameters provided, using default parameters for {points_np.shape[1]}D point cloud")
        if points_np.shape[1] == 2:
            normal_params = {'k_neighbors': 10}
        elif points_np.shape[1] == 3:
            normal_params = {'radius': 0.1, 'max_neighbors': 30}
        else:
            raise ValueError(f"Unsupported point dimension: {points_np.shape[1]}. Only 2D and 3D supported.")
    
    # Compute normals
    normals, _ = compute_pointcloud_normals(points_np, method='auto', **normal_params)
    
    return normals

class DNetPointcloudDataset(Dataset):
    """
    Dataset for a point cloud generated by a diffusion net.
    """
    def __init__(self, data, feature_map, dnet_model, compute_normals=False, normal_params=None):
        """
        Args:
            data (numpy.ndarray): Raw data, e.g., atomic coordinates.
                                  Shape (n_samples, n_features).
            feature_map (torch.nn.Module): A feature map to transform the raw data.
            dnet_model (torch.nn.Module): A trained diffusion net model.
            compute_normals (bool): Whether to compute point cloud normals.
            normal_params (dict): Parameters for normal computation.
        """
        super().__init__()
        self.feature_map = feature_map
        self.dnet_model = dnet_model
        self.compute_normals = compute_normals
        
        # Ensure models are in evaluation mode
        self.feature_map.eval()
        self.dnet_model.eval()

        # Generate the point cloud
        with torch.no_grad():
            data_tensor = torch.tensor(data, dtype=torch.float32)
            features = self.feature_map(data_tensor)
            self.point_cloud = self.dnet_model(features)
        
        # Compute normals if requested
        self.normals = None
        if self.compute_normals:
            print(f"Computing normals for {self.point_cloud.shape[1]}D point cloud...")
            normals_np = compute_pointcloud_normals_for_dataset(self.point_cloud, normal_params)
            self.normals = torch.tensor(normals_np, dtype=torch.float32)

    def __len__(self):
        return len(self.point_cloud)

    def __getitem__(self, idx):
        if self.compute_normals and self.normals is not None:
            return idx, self.point_cloud[idx], self.normals[idx]
        else:
            return idx, self.point_cloud[idx]

class PointCloudDataset(Dataset):
    """
    A simple dataset for a pre-computed point cloud.
    """
    def __init__(self, point_cloud, compute_normals=False, normal_params=None):
        """
        Args:
            point_cloud (numpy.ndarray or torch.Tensor): The point cloud data.
            compute_normals (bool): Whether to compute point cloud normals.
            normal_params (dict): Parameters for normal computation.
        """
        super().__init__()
        if not isinstance(point_cloud, torch.Tensor):
            self.point_cloud = torch.tensor(point_cloud, dtype=torch.float32)
        else:
            self.point_cloud = point_cloud
        
        self.compute_normals = compute_normals
        
        # Compute normals if requested
        self.normals = None
        if self.compute_normals:
            print(f"Computing normals for {self.point_cloud.shape[1]}D point cloud...")
            normals_np = compute_pointcloud_normals_for_dataset(self.point_cloud, normal_params)
            self.normals = torch.tensor(normals_np, dtype=torch.float32)

    def __len__(self):
        return len(self.point_cloud)

    def __getitem__(self, idx):
        if self.compute_normals and self.normals is not None:
            return idx, self.point_cloud[idx], self.normals[idx]
        else:
            return idx, self.point_cloud[idx]


class PointCloudWithNormalsDataset(Dataset):
    """
    A dataset specifically designed for point clouds with their computed normals.
    Automatically computes normals for 2D or 3D point clouds.
    """
    def __init__(self, point_cloud, normal_params=None, orient_to_center=True):
        """
        Args:
            point_cloud (numpy.ndarray or torch.Tensor): The point cloud data.
                                                         Shape (N, D) where D is 2 or 3.
            normal_params (dict): Parameters for normal computation.
                                For 2D: {'k_neighbors': 10}
                                For 3D: {'radius': 0.1, 'max_neighbors': 30}
            orient_to_center (bool): Whether to orient normals away from center of mass.
        """
        super().__init__()
        
        # Convert to tensor if needed
        if not isinstance(point_cloud, torch.Tensor):
            self.point_cloud = torch.tensor(point_cloud, dtype=torch.float32)
        else:
            self.point_cloud = point_cloud
        
        # Validate dimensions
        if self.point_cloud.shape[1] not in [2, 3]:
            raise ValueError(f"Point cloud must be 2D or 3D, got {self.point_cloud.shape[1]}D")
        
        # Set default normal parameters
        if normal_params is None:
            if self.point_cloud.shape[1] == 2:
                normal_params = {'k_neighbors': 10}
            else:  # 3D
                normal_params = {'radius': 0.1, 'max_neighbors': 30}
        
        # Add orientation parameter
        normal_params['orient_to_center'] = orient_to_center
        
        # Compute normals
        print(f"Computing normals for {self.point_cloud.shape[0]} points in {self.point_cloud.shape[1]}D space...")
        normals_np = compute_pointcloud_normals_for_dataset(self.point_cloud, normal_params)
        self.normals = torch.tensor(normals_np, dtype=torch.float32)
        
        print(f"Dataset created with {len(self)} points and normals")

    def __len__(self):
        return len(self.point_cloud)

    def __getitem__(self, idx):
        """
        Returns:
            tuple: (index, point, normal) where point and normal have the same dimensionality
        """
        return idx, self.point_cloud[idx], self.normals[idx]
    
    def get_points(self):
        """Get all points as a tensor."""
        return self.point_cloud
    
    def get_normals(self):
        """Get all normals as a tensor."""
        return self.normals
    
    def get_points_and_normals(self):
        """Get both points and normals as tensors."""
        return self.point_cloud, self.normals 